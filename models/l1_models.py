# Nion Orchestration Engine - Enhanced L1 Models
# Defines the task planning output schema with dependencies and metadata

from typing import Literal, List, Optional, Dict, Any
from pydantic import BaseModel, Field
from datetime import datetime


# Domain types aligned to MVP scope
DomainType = Literal[
    "TRACKING_EXECUTION",
    "COMMUNICATION_COLLABORATION",
    "LEARNING_IMPROVEMENT"
]

# L3 agent types for cross-cutting concerns
L3AgentType = Literal[
    "action_item_extraction",
    "risk_extraction",
    "decision_extraction",
    "knowledge_retrieval",
    "qna",
    "evaluation",
    "message_delivery"
]

PriorityType = Literal["high", "medium", "low"]


class Sender(BaseModel):
    """Message sender information"""
    name: str
    role: Optional[str] = None


class Message(BaseModel):
    """Input message structure matching testio.md format"""
    message_id: str = Field(..., alias="message_id")
    source: str = Field(default="email")
    sender: Sender
    content: str
    project: Optional[str] = None
    
    class Config:
        populate_by_name = True


class L1Task(BaseModel):
    """Represents a single task identified by L1 orchestrator"""
    task_id: str = Field(..., description="Unique task identifier (format: TASK-XXX)")
    domain: DomainType = Field(..., description="Target domain for L2 routing")
    l3_agent: Optional[L3AgentType] = Field(None, description="Specific L3 agent for cross-cutting tasks")
    description: str = Field(..., description="Clear, actionable task description")
    purpose: str = Field(default="", description="Purpose of this task")
    priority: PriorityType = Field(default="medium", description="Task priority level")
    depends_on: List[str] = Field(default_factory=list, description="Task IDs this depends on")
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "TASK-001",
                "domain": "TRACKING_EXECUTION",
                "l3_agent": "action_item_extraction",
                "description": "Extract action items from customer request",
                "purpose": "Identify actionable items that need tracking",
                "priority": "high",
                "depends_on": []
            }
        }


class L1TaskPlan(BaseModel):
    """The complete task plan generated by L1 orchestrator"""
    tasks: List[L1Task] = Field(default_factory=list, description="List of identified tasks")
    source_message_id: Optional[str] = Field(None, description="ID of the source message")
    source_message: Optional[Message] = Field(None, description="Original message metadata")
    created_at: datetime = Field(default_factory=datetime.now, description="Plan creation timestamp")
    
    def get_tasks_by_domain(self, domain: DomainType) -> List[L1Task]:
        """Filter tasks by domain for L2 routing"""
        return [task for task in self.tasks if task.domain == domain]
    
    def get_tasks_by_agent(self, agent: L3AgentType) -> List[L1Task]:
        """Filter tasks by L3 agent type"""
        return [task for task in self.tasks if task.l3_agent == agent]
    
    def get_high_priority_tasks(self) -> List[L1Task]:
        """Get all high priority tasks"""
        return [task for task in self.tasks if task.priority == "high"]
    
    def get_execution_order(self) -> List[L1Task]:
        """Return tasks in dependency-respecting order (topological sort)"""
        completed = set()
        result = []
        remaining = list(self.tasks)
        
        while remaining:
            made_progress = False
            for task in remaining[:]:
                if all(dep in completed for dep in task.depends_on):
                    result.append(task)
                    completed.add(task.task_id)
                    remaining.remove(task)
                    made_progress = True
            
            if not made_progress and remaining:
                # Circular dependency or missing dependency, add remaining in order
                result.extend(remaining)
                break
        
        return result


class L1OrchestratorResult(BaseModel):
    """Result wrapper for L1 orchestration including metadata"""
    success: bool = Field(default=True, description="Whether planning succeeded")
    task_plan: L1TaskPlan = Field(default_factory=L1TaskPlan, description="The generated task plan")
    raw_response: Optional[str] = Field(None, description="Raw LLM response for debugging")
    error: Optional[str] = Field(None, description="Error message if planning failed")
